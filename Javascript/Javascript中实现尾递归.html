<p>通常情况下，我们可以利用函数传统递归调用来消灭命令式编程范型中的循环结构，但由于每次函数调用都要保留私有数据和上下文环境，因此会消耗大量的栈空间。但是递归中也可以存在不占用栈的情况，这就是<a href="http://baike.baidu.com/view/1439396.htm" target="_blank" title="百度百科中关于尾递归的参考">尾递归</a>，尽管Javascript的解释环境中并不支持这种特性及其优化技术，但我们可以人为的实现尾递归算法。</p><!--more-->
<p>这里我举最经典的<a href="http://baike.baidu.com/view/112871.htm" target="_blank" title="百度百科中关于斐波那契数列的参考">斐波那契数列</a>的尾递归版实现来说明问题。</p>
<pre class="brush: js">
//注意：我这里斐波那契数列的开始n为1    
function fibonacci(n) {
    return (function(a, b, i) {
        return (i < n) ? arguments.callee(b, a + b, i + 1) : a;
    })(1, 1, 1);
}
for (var i = 1; i < 21; i++) {
    print('n = ' + i + ' 时为：' + fibonacci(i));
}

//显示结果为：
n = 1 时为：1
n = 2 时为：1
n = 3 时为：2
n = 4 时为：3
n = 5 时为：5
n = 6 时为：8
n = 7 时为：13
n = 8 时为：21
n = 9 时为：34
n = 10 时为：55
n = 11 时为：89
n = 12 时为：144
n = 13 时为：233
n = 14 时为：377
n = 15 时为：610
n = 16 时为：987
n = 17 时为：1597
n = 18 时为：2584
n = 19 时为：4181
n = 20 时为：6765
</pre>
<p>这就和利用循环（迭代）来实现求斐波那契数列效率是一样的了，不信可以测试一下。</p>