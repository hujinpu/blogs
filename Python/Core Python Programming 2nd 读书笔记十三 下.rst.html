<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.4.1: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:Date: $Date: 2005-12-18 01:56:14 +0100 (Sun, 18 Dec 2005) $
:Revision: $Revision: 4224 $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left {
  clear: left }

img.align-right {
  clear: right }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

tt.docutils {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document">
<!-- -*- mode: rst -*- -->
<p>当类之间有显著的不同，并且（较小的类）是较大的类所需要的组件时，组合表现得很好，但当你设计“相同的类但有一些不同的功能”时，派生就是一个更加合理的选择了。</p>
<p><tt class="docutils literal"><span class="pre">__bases__</span></tt> 类属性是一个包含其父类的集合的元组</p>
<pre class="literal-block">
&gt;&gt;&gt; class A(object): pass

&gt;&gt;&gt; class B(A): pass

&gt;&gt;&gt; class C(B): pass

&gt;&gt;&gt; class D(B, A): pass

&gt;&gt;&gt; A.__bases__
(&lt;type 'object'&gt;,)
&gt;&gt;&gt; B.__bases__
(&lt;class '__main__.A'&gt;,)
&gt;&gt;&gt; C.__bases__
(&lt;class '__main__.B'&gt;,)
&gt;&gt;&gt; D.__bases__
(&lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;)
</pre>
<p>Python中有一个很不一样的地方，和Java不同，子类被构造时，如果有自己的 <tt class="docutils literal"><span class="pre">__init__</span></tt> 方法，就不会去调用父类的 <tt class="docutils literal"><span class="pre">__init__</span></tt> 方法了。而且可以用下面的方式调用一个类里定义的方法：</p>
<pre class="literal-block">
&gt;&gt;&gt; class Test2(object):
        &#64;staticmethod
        def say():
                print 'static method say'

&gt;&gt;&gt; Test2.say()
static method say
&gt;&gt;&gt; class Test(object):
        def say(self):
                print 'normal method say'

&gt;&gt;&gt; Test.say(Test())
normal method say
</pre>
<p>注意和静态方法区别</p>
<p>同时，如果想更加方便的调用被子类覆盖的父类的方法，Python引入了 <tt class="docutils literal"><span class="pre">super()</span></tt> 内建方法</p>
<pre class="literal-block">
&gt;&gt;&gt; class Test(object):
        def say(self):
                print 'normal method say'


&gt;&gt;&gt;
&gt;&gt;&gt; class P(object):
        def __init__(self):
                print 'P init'


&gt;&gt;&gt; class C(P):
        def __init__(self):
                super(C, self).__init__()
                print 'C init'


&gt;&gt;&gt; C()
P init
C init
&lt;__main__.C object at 0x011A7EB0&gt;
</pre>
<p><strong>所有的</strong> <tt class="docutils literal"><span class="pre">__new__</span></tt> <strong>方法都是类方法（classmethod）</strong> ，可以用来扩展标准不可变类型（扩展可变类型通常不需要用 <tt class="docutils literal"><span class="pre">__new__</span></tt> 和 <tt class="docutils literal"><span class="pre">__init__</span></tt> ）</p>
<pre class="literal-block">
&gt;&gt;&gt; class RoundFloat(float):
        def __new__(cls, val):
                return super(RoundFloat, cls).__new__(cls, round(val,2))


&gt;&gt;&gt; RoundFloat(1.5955)
1.6000000000000001
</pre>
<p>经典类按照深度优先的原则查找属性，而新式类采用广度优先的算法，同时新式类还有一个 <tt class="docutils literal"><span class="pre">__mro__</span></tt> 属性，可以得到广度查找中的顺序</p>
<pre class="literal-block">
class P1(object):
    def foo(self):
        print 'called P1-foo'

class P2(object):
    def foo(self):
        print 'called P2-foo'

    def bar(self):
        print 'called P2-bar'

class C1(P1, P2):
    pass

class C2(P1, P2):
    def bar(self):
        print 'C2-bar'

class GC(C1, C2):
    pass

gc = GC()
gc.foo()
gc.bar()
P2.bar(GC())
print GC.__mro__
</pre>
<p><tt class="docutils literal"><span class="pre">issubclass(sub,</span> <span class="pre">sup)</span></tt> 布尔函数判断一个类是另一个类的子类或子孙类，sub可以和sup为同一个类。</p>
<p><tt class="docutils literal"><span class="pre">isinstanceof(obj,</span> <span class="pre">cls)</span></tt> 判断一个对象是否是一个类的实例，它的性能很好，因为它是用C写的。cls可以是一个类的元组。</p>
<p><tt class="docutils literal"><span class="pre">*attr</span></tt> 使用很频繁</p>
<pre class="literal-block">
class MyClass(object):
    def __init__(self):
        self.foo = 100

myInst = MyClass()
print hasattr(myInst, 'foo')
print getattr(myInst, 'foo')
print getattr(myInst, 'bar', 'no bar')
setattr(myInst, 'bar', 'oops!')
print dir(myInst)
</pre>
<p>一个有意思的定制的迭代类：</p>
<pre class="literal-block">
#!/usr/bin/env python

class AnyIter(object):
    def __init__(self, data, safe=0):
        self.safe = safe
        self.iter = iter(data)

    def __iter__(self):
        return self

    def next(self, howmany=1):
        retval = []
        for eachItem in range(howmany):
            try:
                retval.append(self.iter.next())
            except StopIteration:
                if self.safe:
                    break
                else:
                    raise
        return retval

a = AnyIter(range(10), True)
#print a.next(14)
for j in range(1, 5):
    print j, ':', a.next(j)
</pre>
<p><strong>默认情况下，属性在Python中都是“public”的</strong></p>
<p>由双下划线开始的属性在运行时被“混淆”，所以直接访问是不允许的。实际上，会在名字前面加上下划线和类名，即 <tt class="docutils literal"><span class="pre">_classname</span></tt> 。</p>
<p>简单的模块级私有化只需要在属性名前使用一个单下划线字符，这就防止模块的属性用 <tt class="docutils literal"><span class="pre">from</span> <span class="pre">mymodule</span> <span class="pre">import</span> <span class="pre">*</span></tt> 来加载</p>
<p>实现授权的关键点就是覆盖 <tt class="docutils literal"><span class="pre">__getattr__()</span></tt> 方法</p>
<p>字典会占据大量内存，如果你有一个属性数量很少的类，但有很多实例，那么正好是这种情况。为内存上的考虑，用户现在可以使用 <tt class="docutils literal"><span class="pre">__slots__</span></tt> 属性来替代 <tt class="docutils literal"><span class="pre">__dict__</span></tt> 。基本上， <tt class="docutils literal"><span class="pre">__slots__</span></tt> 是一个类变量，由一序列型对象组成，由所有合法标识构成的实例属性的集合来表示。它可以是一个列表，元组或可迭代对象。也可以是标识实例能拥有的唯一的属性的简单字符串。</p>
<p>带 <tt class="docutils literal"><span class="pre">__slots__</span></tt> 属性的类定义不会存在 <tt class="docutils literal"><span class="pre">__dict__</span></tt> 了（除非你在其中加入 <tt class="docutils literal"><span class="pre">__dict__</span></tt> 元素），且用户不能随心所欲的动态增加实例属性。</p>
<p>556 描述符</p>
</div>
</body>
</html>
